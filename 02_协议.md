# 协议

- [消息协议的一些要点](#消息协议的一些要点)
- [消息边界](#消息边界)
- [消息结构](#消息结构)
- [消息压缩](#消息压缩)
- [Redis文本协议结构](#Redis文本协议结构)


## 消息协议的一些要点

- 消息边界：特殊符号分割法、长度前缀法
- 消息表示：二进制、文本
- 消息结构：有模式、无模式
- 消息压缩

## 消息边界

### 特殊符号

最常见的分隔符号是`\r\n`。

- 优点：可读性好
- 缺点：二进制很容易就出现`\r\n`。因此最好先用base64普通文本消息再进行传送

### 长度前缀法

- 优点：二进制和文本都可以
- 缺点：可读性不好

HTTP两种方法混合使用

- 消息头用`\r\n`
- 消息体用头部中的`Content-Length`

> HTTP的消息体可以是文本，也可以是二进制内容，如视频、音频

## 消息结构

### 显式结构

> 如json就是显式结构

- 优点是易读
- 缺点是冗余信息，如引号、冒号等

### 隐式结构

在 RPC 交互的消息数据中只是纯粹的二进制数据，由代码来确定相应位置的二进制是属于哪个字段。如下面

```cs
// 发送端写消息
class AuthUserOutput {
	int platformId;
	long deviceId;
	String productId;
	String channelId;
	String versionId;
	String phoneModel;
	
	@Override
	public void writeImpl() {
		writeByte((byte) this.platformId);
		writeLong(deviceId);
		writeStr(productId);
		writeStr(channelId);
		writeStr(versionId);
		writeStr(phoneModel);
	}
}
```

## 消息压缩

如果消息的内容太大，就要考虑对消息进行压缩处理，这可以减轻网络带宽压力。但是这同时也会加重 CPU 的负担，因为压缩算法是 CPU 计算密集型操作，会导致操作系统的负载加重。所以，最终是否进行消息压缩，一定要根据业务情况加以权衡。

如果确定压缩，那么在选择压缩算法包时，务必挑选那些底层用 C 语言实现的算法库，因为 Python 的字节码执行起来太慢了。比较流行的消息压缩算法有 Google 的 snappy 算法，它的运行性能非常好，压缩比例虽然不是最优的，但是离最优的差距已经不是很大。阿里的 SOFA RPC 就使用了 snappy 作为协议层压缩算法。

### 两个优化的例子

#### varint

一般我们使用的整数不会很大，用4字节太浪费了。varint是变长字节的整数。保留每个字节的最高位的 bit 来标识是否后面还有字节，1 表示还有字节需要继续读，0 表示到读到当前字节就结束。

#### zigzag编码

zgizag编码是为了解决负数用varint的问题。zigzag 编码将整数范围一一映射到自然数范围

zigzag 将负数编码成正奇数，正数编码成偶数。

解码：

- 偶数：直接除2就是原值
- 基数：加1除2再取负就是原值


```
0 => 0
-1 => 1
1 => 2
-2 => 3
2 => 4
-3 => 5
3 => 6
```

## Redis文本协议结构

### 深入理解 RESP (Redis Serialization Protocol)

RESP的最大特点是直观。其把数组分成集中类型，结束时统一加上回车换行符`\r\n`

- 单行字符串以`+`开头

```
+hello world\r\n
```

- 多行字符串以`$`开头，后面跟字符串的长度

```
$11hello world\r\n
```

- 整数以`:`开头，接整数的字符串表示

```
:1024\r\n
```

- 错误以`-`开头，后跟错误名称和详细错误解释

```
-WRONGTYPE Operation against a key holding the wrong kind of value\r\n
```

- 数组以`*`开头，后接数组长度。数组的每一段都用`\r\n`分隔。下面是数组[1,2]。数组里面可以嵌套不同的类型

```
*2\r\n:1\r\n:2\r\n
```

两个特殊

- `NULL`写成`$-1\r\n`
- 空串是`$0\r\n\r\n`

